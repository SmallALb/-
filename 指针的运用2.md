# 指针的运用（2）

## 指针的一些零散语法

### 开辟


如果后面不做开发工作,知道怎么用就好

```cpp
int* p = (int*)calloc(10, sizeof(int));
```

开辟空间并且传入的值都为0， 什么意思呢，比如上面，这段开辟一个长度为10的数组，且每个位置上的数据都是0

也就是同等于 int arr[10] = {0,0,0,0,0,0,0,0,0,0}

```cpp
int* p2 = (int*) realloc(p, 3*sizeof(int));
```

这个就有意思了，在内存够用的情况下，他会在 p 指针后面再开辟三个空间， 但是不会进行初始化操作， 也就是说你新开辟的空间上面是没有数据的。

而且这里还说了，在内存够用的情况下， 那要是不够用呢，

他会另外找一段空间进行开辟，并且为了保证数据之间的连续性，他会将原来的那段空间给复制到另一段足够大的空间上去，

并且在后面再加上要新开辟的空间。

那么原来那段空间就要删除了。


这只是相对来说不够用了，但是还有完全不够用的，可是怎么会完全不够用呢？

对于现代计算机来说，确实很难不够用，但是对于单片机，嵌入式开发，内存的管理就尤其的重要了，

当内存完全不够用的时候这个语法会返回一个空指针。


### 复制

```cpp
int* p = (int*)calloc(6, sizeof(int));
int* p2 = (int*)calloc(3, sizeof(int));
memcpy(p+6, p2, 3*sizeof(int));
```

复制的代码有很多很多种，但是这里只讲这个最简单的 memcpy()

第一个值为  要复制进去地址的开头， 这里为啥要p+6呢？

该代码中往p中开辟了6个整形大小的空间，之前我们学过   p   代表着我们开辟的空间的首地址

那么 复制就得往后面还没有开辟的地方粘贴过去，即从开辟的这段空间最后一个的地址位置开始，  所以要传入 p + 6。

第二个则代表你要复制的内容，这里复制p2过去，所以传入p2

最后再告诉这个函数要传入数据的长度是多少就可以，这里是3个整形的长度。



你肯定会觉得， 这和realloc函数有什么区别吗？

因为我是吧数据给复制到了  p   开辟空间的末端，但如果我对  p   里面部分的数据进行覆盖呢？（比如说做个屏蔽词检测）这样灵活性就比realloc高的多的多。


而且memcpy不单单只能用在指针，更多是用在字符数组，普通的数组上（char*开辟的字符串不可以用，具体看上一篇的文章）

```cpp
char str1[50] = "happy ";
char str2[50] = "new year";
memcpy(str1+6, str2, sizeof(char)*8);
cout<<str1<<endl;
```

本质上这是（string.h）里面的语法，但是奈何实用性过高，所以这里拿来讲讲，还有一些什么memccpy,，memset......之类的不在这讲了，只要理解了这个其他的都很容易理解


## 注意事项

这篇笔记比较短，但是比较难以理解（如果一下能理解那前面的知识基本都很牢固了），所以这里单独开了模块，相当于做一些补充。下一篇文章就是二维数组与指针的操作了
