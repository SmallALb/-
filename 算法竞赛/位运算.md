# 位运算

二进制位运算的空间和时间上都能够节省很多，位运算在后面的状态DP上也是尤为重要的东西

## 基本位运算符

### & （逻辑与）

1 & 1 = 1   1 & 0 = 0    两个位置对应为 1 的时候才成立 为1

```cpp
0111010 & 0010010 = 0010010
```

### |     (逻辑或)

1 | 1 = 1   1 | 0 = 1   0 | 0 = 0    两个对应的位置中任意一个 为 1 就成立 为1

```cpp
01100 | 00010 = 01110
```

### ^  （异或）

1^1 = 0       0^0 = 0     1^0= 1     两对应的位置上不同则成立 为1

```cpp
01010 ^ 10011 = 11001
```

### ~    (按位取反)

每一位都取反  1 变 0  0变1

```cpp
~01101001 = 10010110
```

注意取反的时候表示符号的位置也会被取反，因此取反后会变成负数

### <<   and   >>    位左移和右移

1 << 3 = 1000    10000  >> 3 = 10  会将二进制往  左/右  移动 i 位

就相当于将这原来的数  乘以/除以   2的i次方   比如  1<<3 == 1* (2^3)

```cpp
10100 >> 2 = 101
```

但是要注意的是不能超过范围，比如整形的最大移动为 32， 也不能小于0

### tips:

负数的二进制的形式，是怎么出来的呢？

其实负数就是 他原来的正数按位取反后 再 +1 得到的结果，这个 +1的行为 就叫做补码

这里以 -5 为例子：

> 5 == (000101)2
>
> -6 == ~5 == (111010)2
>
> -6 + 1 == -5 == (111011)2
>
> 因此  -5 == (~5) + 1
>
> 或者说 (~5) ==  -5-1

而对于正数的补码就是他的本身

## 位运算的各种使用情况以一些算法

因为位运算的速度特别的快因此在某些特定情况下可以做很多很快的操作

绝对值运算：

```cpp
int ABS(int num) {
    return (num ^ (num>>31)) - (num>>31);
}
```

将这个数右移31位得到他二进制上表示符号的位置，如果是正数 那右移31位后得到的数是0

那么 num ^ (num>>31) = num    (即为num ^ 000000)，再减去符号位的相反数 （0的相反数就是0）

对于负数呢？

位移31位得到的符号位是 -1 == (11111111111...)2

然后对位移后的数和原来的数进行异或操作  比如 -3 (11111101) y

-3 ^ (-3>>31)   就是    -3 ^ -1 = 2

最后再减去他符号位的相反数 即 -(num>>31) = 2 + 1 = 3

算最大值和最小值：

```cpp
int MIN(int a, int b) {
    return (a & (a-b>>31)) | (a & (~(a-b)>>31));
}

int MAX(int a, int b) {
    return (b & (a-b>>31)) | (a & (~(a-b)>>31));
}
```

整数交换：

```cpp
void swap(int& a, int& b) {
    a ^= b;
    b ^= a;
    a ^= b;
}
```

快速幂:

```cpp
int a, n; cin>>a>>n;
int num = a;
while(n) {
   if (n & 1)  a *= num;
   num *= num;
   n >>= 1;
}

```

## 内置的函数

```cpp
int __builtin_ffs(int x)
```

返回二进制末尾最后一个1的位置，编号从1开始


```cpp
int __builtin_clz(unsigned int x)
```

二进制前导0个数， x为0时不会返回值 （只能使用无符号类型的数据）


```cpp
int __builtin_ctz(unsigned int x)
```

返回末尾连续0个数


```cpp
int __builtin_clrsb(int x)
```

判断符号位是不是负数，是就返回 x 前导0个数-1，否则返回前导1个数-1


```cpp
int __builtin_popcount(unsigned int x)
```

返回二进制中 1 的个数


```cpp
int __builtin_parity(unsigned int x)
```

判断二进制中 1 的个数的奇偶性
